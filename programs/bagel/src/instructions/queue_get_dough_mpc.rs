use anchor_lang::prelude::*;
use arcium_anchor::prelude::*;
use crate::{constants::*, error::*, privacy::*, state::*};

/// Queue MPC computation for accrued salary calculation
/// 
/// This instruction queues an Arcium MPC computation to calculate:
/// accrued_salary = encrypted_salary_per_second * elapsed_seconds
/// 
/// The computation happens asynchronously on Arcium's MXE cluster.
/// Once complete, Arcium will call back to `finalize_get_dough_from_mpc_callback`.
/// 
/// **REAL PRIVACY:** The salary amount stays encrypted throughout the computation.
pub fn handler(
    ctx: Context<QueueGetDoughMpc>,
    computation_offset: u64,
    elapsed_seconds: u64,
) -> Result<()> {
    let payroll_jar = &ctx.accounts.payroll_jar;
    
    // Verify payroll is active
    require!(payroll_jar.is_active, BagelError::InvalidState);
    
    // Reconstruct encrypted salary from stored ciphertext
    let encrypted_salary = EncryptedU64 {
        ciphertext: payroll_jar.encrypted_salary_per_second.clone(),
        encryption_pubkey: None,
    };
    
    msg!("ðŸ”® Queueing MPC computation for accrued salary");
    msg!("   Elapsed seconds: {}", elapsed_seconds);
    msg!("   Encrypted salary: {} bytes", encrypted_salary.ciphertext.len());
    
    // Build MPC inputs using ArgBuilder
    // Input 1: encrypted_salary_per_second (32 bytes) - encrypted data
    // Input 2: elapsed_seconds (u64) - plaintext scalar
    use crate::constants::ARCIUM_CLUSTER_OFFSET;
    use arcium_anchor::prelude::ArgBuilder;
    
    // Build arguments using ArgBuilder
    // The encrypted salary is already encrypted (32 bytes)
    // We pass it as encrypted data, and elapsed_seconds as plaintext
    let encrypted_bytes: [u8; 32] = encrypted_salary.ciphertext[0..32]
        .try_into()
        .map_err(|_| error!(BagelError::InvalidAmount))?;
    
    let args = ArgBuilder::new()
        .encrypted_u8(encrypted_bytes)  // [u8; 32] - encrypted salary
        .plaintext_u64(elapsed_seconds) // u64 - elapsed seconds
        .build();
    
    msg!("   âœ… MPC inputs prepared using ArgBuilder");
    
    // Build callback instruction using macro-generated callback_ix() method
    // The #[callback_accounts] macro on FinalizeGetDoughFromMpcCallback generates
    // the CallbackCompAccs trait implementation with callback_ix() method
    // We need to use the trait method directly - the macro generates it on the struct
    use arcium_anchor::traits::CallbackCompAccs;
    
    // The callback_ix method is generated by #[callback_accounts] macro
    // We need to construct a temporary instance or use the trait directly
    // For now, let's use the trait method pattern
    let callback_ix = <crate::instructions::finalize_get_dough_from_mpc_callback::FinalizeGetDoughFromMpcCallback as CallbackCompAccs>::callback_ix(
        ARCIUM_CLUSTER_OFFSET,
        &ctx.accounts.mxe_account,
        &[], // No extra accounts needed
    )?;
    
    msg!("   âœ… Callback instruction built using macro-generated callback_ix()");
    
    // Set the signer PDA bump (required by Arcium)
    ctx.accounts.sign_pda_account.bump = ctx.bumps.get("sign_pda_account").copied().unwrap_or(0);
    
    // Queue the computation with callback
    queue_computation(
        &ctx.accounts,
        computation_offset,      // computation_offset (from instruction)
        args,                    // args: ArgumentList
        None,                    // callback_url: Option<String> (None for on-chain)
        vec![callback_ix],       // callback_instructions (generated by macro)
        1,                       // num_callback_txs
        1000,                    // cu_price_micro (priority fee)
    )?;
    
    msg!("   âœ… MPC computation queued on Arcium MXE cluster");
    msg!("   ðŸ”„ Waiting for callback: finalize_get_dough_from_mpc_callback");
    
    Ok(())
}

// NOTE: QueueGetDoughMpc struct has been moved to lib.rs (crate root)
// to fix Anchor macro expansion for __client_accounts_* symbols
