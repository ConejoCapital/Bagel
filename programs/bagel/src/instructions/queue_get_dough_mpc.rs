use anchor_lang::prelude::*;
use arcium_anchor::prelude::*;
use crate::{constants::*, error::*, privacy::*, state::*};

/// Queue MPC computation for accrued salary calculation
/// 
/// This instruction queues an Arcium MPC computation to calculate:
/// accrued_salary = encrypted_salary_per_second * elapsed_seconds
/// 
/// The computation happens asynchronously on Arcium's MXE cluster.
/// Once complete, Arcium will call back to `finalize_get_dough_from_mpc_callback`.
/// 
/// **REAL PRIVACY:** The salary amount stays encrypted throughout the computation.
pub fn handler(
    ctx: Context<QueueGetDoughMpc>,
    computation_offset: u64,
    elapsed_seconds: u64,
) -> Result<()> {
    let payroll_jar = &ctx.accounts.payroll_jar;
    
    // Verify payroll is active
    require!(payroll_jar.is_active, BagelError::InvalidState);
    
    // Reconstruct encrypted salary from stored ciphertext
    let encrypted_salary = EncryptedU64 {
        ciphertext: payroll_jar.encrypted_salary_per_second.clone(),
        encryption_pubkey: None,
    };
    
    msg!("ðŸ”® Queueing MPC computation for accrued salary");
    msg!("   Elapsed seconds: {}", elapsed_seconds);
    msg!("   Encrypted salary: {} bytes", encrypted_salary.ciphertext.len());
    
    // Build MPC inputs using ArgBuilder
    // Input 1: encrypted_salary_per_second (32 bytes) - encrypted data
    // Input 2: elapsed_seconds (u64) - plaintext scalar
    use crate::constants::ARCIUM_CLUSTER_OFFSET;
    use arcium_anchor::prelude::ArgBuilder;
    
    // Build arguments using ArgBuilder
    // The encrypted salary is already encrypted (32 bytes)
    // We pass it as encrypted data, and elapsed_seconds as plaintext
    let encrypted_bytes: [u8; 32] = encrypted_salary.ciphertext[0..32]
        .try_into()
        .map_err(|_| error!(BagelError::InvalidAmount))?;
    
    let args = ArgBuilder::new()
        .encrypted_u8(encrypted_bytes)  // [u8; 32] - encrypted salary
        .plaintext_u64(elapsed_seconds) // u64 - elapsed seconds
        .build();
    
    msg!("   âœ… MPC inputs prepared using ArgBuilder");
    
    // Build callback instruction using macro-generated callback_ix() method
    // The #[callback_accounts] macro on FinalizeGetDoughFromMpcCallback generates
    // the CallbackCompAccs trait implementation with callback_ix() method
    // Import from the re-exported module
    use super::finalize_get_dough_from_mpc_callback::FinalizeGetDoughFromMpcCallback;
    
    let callback_ix = FinalizeGetDoughFromMpcCallback::callback_ix(
        ARCIUM_CLUSTER_OFFSET,
        &ctx.accounts.mxe_account,
        &[], // No extra accounts needed
    )?;
    
    msg!("   âœ… Callback instruction built using macro-generated callback_ix()");
    
    // Set the signer PDA bump (required by Arcium)
    ctx.accounts.sign_pda_account.bump = ctx.bumps.get("sign_pda_account").copied().unwrap_or(0);
    
    // Queue the computation with callback
    queue_computation(
        &ctx.accounts,
        computation_offset,      // computation_offset (from instruction)
        args,                    // args: ArgumentList
        None,                    // callback_url: Option<String> (None for on-chain)
        vec![callback_ix],       // callback_instructions (generated by macro)
        1,                       // num_callback_txs
        1000,                    // cu_price_micro (priority fee)
    )?;
    
    msg!("   âœ… MPC computation queued on Arcium MXE cluster");
    msg!("   ðŸ”„ Waiting for callback: finalize_get_dough_from_mpc_callback");
    
    Ok(())
}

/// Queue MPC computation accounts
/// 
/// Uses Arcium's #[queue_computation_accounts] macro to generate the QueueCompAccs trait
/// and ensure all required Arcium accounts are present with correct constraints.
#[queue_computation_accounts("queue_get_dough_mpc", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64)]
pub struct QueueGetDoughMpc<'info> {
    // Bagel-specific accounts
    #[account(mut)]
    pub employee: Signer<'info>,
    
    /// CHECK: Employer reference needed for PDA derivation
    pub employer: UncheckedAccount<'info>,
    
    #[account(
        seeds = [BAGEL_JAR_SEED, employer.key().as_ref(), employee.key().as_ref()],
        bump,
        has_one = employee,
        has_one = employer,
    )]
    pub payroll_jar: Account<'info, PayrollJar>,
    
    // Arcium accounts (generated by #[queue_computation_accounts] macro)
    // The macro adds: payer, sign_pda_account, mxe_account, mempool_account,
    // executing_pool, computation_account, comp_def_account, cluster_account,
    // pool_account, clock_account, arcium_program, system_program
    
    /// CHECK: Payer for computation fees
    #[account(mut)]
    pub payer: Signer<'info>,
    
    /// CHECK: Signer PDA account (initialized by macro if needed)
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [b"sign_pda"],
        bump
    )]
    pub sign_pda_account: Account<'info, arcium_anchor::prelude::SignerAccount>,
    
    /// CHECK: MXE account (derived PDA)
    #[account(address = derive_mxe_pda!())]
    pub mxe_account: Account<'info, MXEAccount>,
    
    /// CHECK: Mempool account (derived PDA)
    #[account(
        mut,
        address = derive_mempool_pda!(mxe_account, BagelError::InvalidState)
    )]
    pub mempool_account: UncheckedAccount<'info>,
    
    /// CHECK: Executing pool account (derived PDA)
    #[account(
        mut,
        address = derive_execpool_pda!(mxe_account, BagelError::InvalidState)
    )]
    pub executing_pool: UncheckedAccount<'info>,
    
    /// CHECK: Computation account (derived PDA, will be created)
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset, mxe_account, BagelError::InvalidState)
    )]
    pub computation_account: UncheckedAccount<'info>,
    
    /// CHECK: Computation definition account (derived PDA)
    #[account(address = derive_comp_def_pda!(ARCIUM_CLUSTER_OFFSET as u32))]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    
    /// CHECK: Cluster account (derived PDA)
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account, BagelError::InvalidState)
    )]
    pub cluster_account: Account<'info, Cluster>,
    
    /// CHECK: Fee pool account
    #[account(
        mut,
        address = arcium_anchor::prelude::ARCIUM_FEE_POOL_ACCOUNT_ADDRESS
    )]
    pub pool_account: Account<'info, FeePool>,
    
    /// CHECK: Clock account
    #[account(address = arcium_anchor::prelude::ARCIUM_CLOCK_ACCOUNT_ADDRESS)]
    pub clock_account: Account<'info, ClockAccount>,
    
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
}
