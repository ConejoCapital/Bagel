# Cursor Skills Pack: Arcium v0.6.x Development Playbook

## 1. Toolchain & Project Layout

Arcium uses its own CLI (`arcup` + `arcium`) to build circuits and deploy MPC-enabled programs. Install via `arcup install`.

The workspace layout should include:

- `programs/<your_program>` for your Anchor program.
- `encrypted-ixs` as a separate Rust crate for Arcis circuits.

Run `arcium build` (not just `cargo build`) from the workspace root to compile circuits in `encrypted-ixs` and produce `.arcis` artifacts.

## 2. Arcis: Writing Encrypted Instructions

Use `arcis` macros (`#[encrypted] mod circuits`) in `encrypted-ixs/src/lib.rs` to define MPC functions.

Each encrypted function uses `Enc<Shared, T>` or `Enc<Mxe, T>` for inputs and returns `Enc<Shared, U>` or `Enc<Mxe, U>`.

Convert inputs with `.to_arcis()` and return results with `.owner.from_arcis(output)`.

## 3. Program Invocation: Queueing MPC Computations

In your Anchor program, use Arcium's queue API to invoke encrypted instructions.

Define a queue accounts struct annotated with:

```rust
#[queue_computation_accounts("your_encrypted_ix_name", payer)]
#[derive(Accounts)]
#[instruction(computation_offset: u64)]
pub struct QueueYourIx<'info> {
    // payer
    #[account(mut)]
    pub payer: Signer<'info>,
    // sign PDA (exact pattern)
    #[account(
        init_if_needed,
        space = 9,
        payer = payer,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,

    // required Arcium accounts in this exact order:
    pub mxe_account: Account<'info, MXEAccount>,
    pub mempool_account: UncheckedAccount<'info>,
    pub executing_pool: UncheckedAccount<'info>,
    pub computation_account: UncheckedAccount<'info>,
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    pub cluster_account: Account<'info, Cluster>,
    pub pool_account: Account<'info, FeePool>,
    pub clock_account: Account<'info, ClockAccount>,
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,

    // your custom accounts (e.g., payroll jar) go here
}
```

In the handler, set `ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account`.

Use `queue_computation()` with an `ArgBuilder` for your input arguments and supply a `callback_ix()` generated by your callback accounts struct.

## 4. Callbacks: Verifying Outputs

Annotate your callback function with `#[arcium_callback(encrypted_ix = "your_encrypted_ix_name")]`.

Define callback accounts with `#[callback_accounts("your_encrypted_ix_name")]`.

The callback signature must take `SignedComputationOutputs<OutputType>` as a parameter.

Verify and decode:

```rust
let decoded = output
    .verify_output(&ctx.accounts.cluster_account, &ctx.accounts.computation_account)
    .map_err(|_| ErrorCode::AbortedComputation)?;
```

After verification, update your program state or handle the MPC result.

## 5. Macro Hygiene & Naming Conventions

Instruction name, encrypted ix name, callback struct name, and output type must all follow the same pattern:
Encrypted instruction: `queue_get_dough_mpc` → callback struct: `QueueGetDoughMpcCallback` → output type: `QueueGetDoughMpcOutput`.

Always include the `init-if-needed` feature in `anchor-lang` dependency:

```toml
anchor-lang = { version = "0.32.1", features = ["init-if-needed"] }
```

For the `sign_pda_account`, use `Account<'info, SignerAccount>` and Arcium's `SIGN_PDA_SEED` exactly; do not shadow or fully qualify the type.

**Critical:** Avoid wildcard imports that might shadow Arcium's identifiers:
- ❌ `use crate::{constants::*, state::*};` (might shadow `SIGN_PDA_SEED`)
- ✅ `use crate::constants::BAGEL_JAR_SEED;` (explicit imports)
- ✅ `use arcium_anchor::prelude::SIGN_PDA_SEED;` (explicit Arcium import)

**Critical:** Do NOT fully qualify types in the accounts struct:
- ❌ `Account<'info, arcium_anchor::prelude::SignerAccount>`
- ✅ `Account<'info, SignerAccount>`

**Critical:** Do NOT use doc comments (`///`) before `#[account(...)]` attributes:
- ❌ `/// CHECK: Signer PDA account` followed by `#[account(...)]`
- ✅ `// Signer PDA account` followed by `#[account(...)]`

## 6. Real Arcium Workflow

1. Write and test your circuit in `encrypted-ixs`.
2. Run `arcium build` to compile circuits and generate `.arcis` files.
3. Deploy MXE to devnet or mainnet with `arcium deploy`.
4. Initialize your computation definition using an `init` instruction with `init_comp_def()`.
5. Queue computations from your Anchor program with `queue_computation()`.
6. Handle callbacks and verify outputs via `verify_output()` in your callback instruction.

## 7. Debugging Tips

- Always address the first macro panic; subsequent unresolved imports are cascading failures.
- If `arcium build` generates `.arcis.ir` but not `.arcis`, check your `arcium` CLI version and dependencies.
- Avoid extra doc comments before `#[account(...)]` attributes in queue/callback structs; macro pattern matching is strict.
- For any "invalid field type" errors, check for name collisions and that you are using Arcium's own `SignerAccount` and constants.
- If the macro still panics, create a minimal accounts struct with only Arcium-required accounts to isolate the issue.
- Remove `arcium-client` from on-chain program `Cargo.toml`; only use `arcium-anchor` (which depends on `arcium-client` internally).

## 8. Common Pitfalls

1. **Version Mismatch:** Ensure `arcium` CLI version matches your Rust dependencies (both 0.6.1).
2. **Circuit File Missing:** Macro expects `build/<encrypted_ix_name>.arcis` to exist (run `arcium build` first).
3. **Type Shadowing:** Wildcard imports can shadow Arcium's `SignerAccount` or `SIGN_PDA_SEED`.
4. **Fully Qualified Types:** Macro expects plain `SignerAccount`, not `arcium_anchor::prelude::SignerAccount`.
5. **Doc Comments:** `///` comments compile to `#[doc]` attributes which break macro pattern matching.
6. **Account Order:** Arcium accounts must come before custom accounts in the struct.
